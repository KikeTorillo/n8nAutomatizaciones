-- ====================================================================
-- âš¡ FUNCIONES PL/pgSQL DEL SISTEMA SAAS
-- ====================================================================
--
-- Este archivo contiene todas las funciones PL/pgSQL especializadas
-- del sistema, organizadas por funcionalidad.
--
-- ğŸ“Š CONTENIDO:
-- â€¢ Funciones de autenticaciÃ³n y seguridad
-- â€¢ Funciones de mantenimiento automÃ¡tico  
-- â€¢ Funciones de validaciÃ³n y coherencia
-- â€¢ Funciones de timestamp automÃ¡tico
-- â€¢ Funciones operacionales (horarios, limpieza)
--
-- ğŸ”„ ORDEN DE EJECUCIÃ“N: #2 (DespuÃ©s de types-and-enums)
-- âš¡ CARACTERÃSTICAS: 13 funciones con bypass RLS controlado
-- ====================================================================

-- ====================================================================
-- ğŸ” EXTENSIONES PARA BÃšSQUEDA AVANZADA
-- ====================================================================
-- Extensiones necesarias para las funciones de bÃºsqueda fuzzy en modelos
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

-- ExtensiÃ³n para bÃºsqueda fuzzy (funciones similarity() y trigrama)
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- ExtensiÃ³n para normalizaciÃ³n de texto sin acentos
CREATE EXTENSION IF NOT EXISTS unaccent;

-- ====================================================================
-- ğŸ” FUNCIÃ“N 1: REGISTRAR_INTENTO_LOGIN
-- ====================================================================
-- FunciÃ³n CRÃTICA para el sistema de autenticaciÃ³n.
-- Maneja tanto logins exitosos como fallidos con lÃ³gica de bloqueo.
--
-- ğŸ“‹ PARÃMETROS:
-- â€¢ p_email: Email del usuario que intenta autenticarse
-- â€¢ p_exitoso: TRUE = login correcto, FALSE = login fallido
-- â€¢ p_ip_address: IP del cliente (para auditorÃ­a futura)
--
-- ğŸ›¡ï¸ LÃ“GICA DE SEGURIDAD:
-- â€¢ Login exitoso: Resetea contadores y actualiza Ãºltimo acceso
-- â€¢ Login fallido: Incrementa contador e implementa bloqueo progresivo
-- â€¢ Bloqueo automÃ¡tico: 30 minutos tras 5 intentos fallidos
--
-- âš¡ PERFORMANCE: Usa bypass RLS para evitar overhead de polÃ­ticas
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION registrar_intento_login(
    p_email VARCHAR(150),                    -- Email del usuario (identificador Ãºnico)
    p_exitoso BOOLEAN DEFAULT FALSE,         -- TRUE = Ã©xito, FALSE = fallo
    p_ip_address INET DEFAULT NULL           -- IP del cliente (auditorÃ­a futura)
) RETURNS VOID AS $$
DECLARE
    usuario_id INTEGER;                      -- ID del usuario encontrado
    org_id INTEGER;                          -- ID de organizaciÃ³n (para logs futuros)
BEGIN
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 1: CONFIGURAR BYPASS RLS
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- Necesario para que la funciÃ³n pueda actualizar usuarios sin
    -- restricciones de tenant (funciÃ³n de sistema crÃ­tica)
    PERFORM set_config('app.bypass_rls', 'true', true);

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 2: OBTENER INFORMACIÃ“N DEL USUARIO
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    SELECT u.id, u.organizacion_id INTO usuario_id, org_id
    FROM usuarios u
    WHERE u.email = p_email AND u.activo = TRUE;

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 3: PROCESAR RESULTADO DEL LOGIN
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    IF usuario_id IS NOT NULL THEN
        IF p_exitoso THEN
            -- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            -- â”‚ LOGIN EXITOSO: Resetear seguridad y actualizar acceso  â”‚
            -- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            UPDATE usuarios
            SET ultimo_login = NOW(),             -- Timestamp del acceso
                intentos_fallidos = 0,            -- Resetear contador
                bloqueado_hasta = NULL,           -- Quitar bloqueo si existÃ­a
                actualizado_en = NOW()            -- Actualizar timestamp
            WHERE id = usuario_id;
        ELSE
            -- â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            -- â”‚ LOGIN FALLIDO: Incrementar contador y evaluar bloqueo  â”‚
            -- â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            UPDATE usuarios
            SET intentos_fallidos = intentos_fallidos + 1,
                -- LÃ“GICA DE BLOQUEO: 30 min tras 5 intentos (Ã­ndice 4)
                bloqueado_hasta = CASE
                    WHEN intentos_fallidos >= 4 THEN NOW() + INTERVAL '30 minutes'
                    ELSE bloqueado_hasta
                END,
                actualizado_en = NOW()
            WHERE id = usuario_id;
        END IF;

        -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        -- FASE 4: LOGGING Y AUDITORÃA EN EVENTOS_SISTEMA
        -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        -- Registrar evento de intento de login en la tabla de auditorÃ­a
        INSERT INTO eventos_sistema (
            organizacion_id, tipo_evento, descripcion, metadata,
            usuario_id, ip_address, gravedad
        ) VALUES (
            org_id,
            CASE WHEN p_exitoso THEN 'login_success'::tipo_evento_sistema
                 ELSE 'login_failed'::tipo_evento_sistema END,
            CASE WHEN p_exitoso THEN 'Login exitoso registrado'
                 ELSE 'Intento de login fallido registrado' END,
            jsonb_build_object(
                'exitoso', p_exitoso,
                'email', p_email,
                'intentos_previos', CASE WHEN NOT p_exitoso THEN
                    (SELECT intentos_fallidos FROM usuarios WHERE id = usuario_id) + 1
                    ELSE 0 END,
                'bloqueado', CASE WHEN NOT p_exitoso THEN
                    (SELECT intentos_fallidos FROM usuarios WHERE id = usuario_id) >= 4
                    ELSE false END
            ),
            usuario_id,
            p_ip_address,
            CASE WHEN p_exitoso THEN 'info' ELSE 'warning' END
        );
    END IF;

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 5: LIMPIAR CONFIGURACIÃ“N RLS
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    PERFORM set_config('app.bypass_rls', 'false', true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ğŸ“ COMENTARIO DE FUNCIÃ“N EN BD
COMMENT ON FUNCTION registrar_intento_login(VARCHAR, BOOLEAN, INET) IS
'FunciÃ³n crÃ­tica de autenticaciÃ³n. Registra intentos de login y aplica polÃ­ticas de bloqueo automÃ¡tico de seguridad';

-- ====================================================================
-- ğŸ§¹ FUNCIÃ“N 2: LIMPIAR_TOKENS_RESET_EXPIRADOS
-- ====================================================================
-- FunciÃ³n de MANTENIMIENTO automÃ¡tico para limpiar tokens expirados.
-- Debe ejecutarse periÃ³dicamente (cron job o scheduled task).
--
-- ğŸ¯ PROPÃ“SITO:
-- â€¢ Eliminar tokens de reset de contraseÃ±a que ya expiraron
-- â€¢ Liberar espacio y mejorar seguridad
-- â€¢ Mantener la tabla limpia de datos obsoletos
--
-- ğŸ“Š RETORNA: Cantidad de tokens limpiados (para logging)
--
-- â° EJECUCIÃ“N RECOMENDADA: Cada hora o cada 6 horas
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION limpiar_tokens_reset_expirados()
RETURNS INTEGER AS $$
DECLARE
    tokens_limpiados INTEGER;                -- Contador de registros afectados
BEGIN
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 1: CONFIGURAR BYPASS RLS
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FunciÃ³n de mantenimiento necesita acceso global a todos los usuarios
    PERFORM set_config('app.bypass_rls', 'true', true);

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 2: LIMPIAR TOKENS EXPIRADOS
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    UPDATE usuarios
    SET token_reset_password = NULL,          -- Limpiar token
        token_reset_expira = NULL,            -- Limpiar fecha expiraciÃ³n
        actualizado_en = NOW()                -- Actualizar timestamp
    WHERE token_reset_expira < NOW()          -- Solo tokens ya expirados
    AND token_reset_password IS NOT NULL;    -- Solo usuarios con token activo

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 3: OBTENER CANTIDAD DE REGISTROS AFECTADOS
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    GET DIAGNOSTICS tokens_limpiados = ROW_COUNT;

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 4: LOGGING DE MANTENIMIENTO EN EVENTOS_SISTEMA
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- Registrar evento de limpieza automÃ¡tica (solo si se limpiaron tokens)
    IF tokens_limpiados > 0 THEN
        INSERT INTO eventos_sistema (
            organizacion_id, tipo_evento, descripcion, metadata, gravedad
        ) VALUES (
            1, -- OrganizaciÃ³n del sistema (se puede ajustar segÃºn necesidades)
            'tokens_limpiados'::tipo_evento_sistema,
            'Limpieza automÃ¡tica de tokens de reset expirados ejecutada',
            jsonb_build_object(
                'tokens_limpiados', tokens_limpiados,
                'ejecutado_automaticamente', true,
                'funcion', 'limpiar_tokens_reset_expirados'
            ),
            'info'
        );
    END IF;

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 5: LIMPIAR CONFIGURACIÃ“N RLS
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    PERFORM set_config('app.bypass_rls', 'false', true);

    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -- FASE 6: RETORNAR RESULTADO
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    RETURN tokens_limpiados;
END;
$$ LANGUAGE plpgsql;

-- ğŸ“ COMENTARIO DE FUNCIÃ“N EN BD
COMMENT ON FUNCTION limpiar_tokens_reset_expirados() IS
'FunciÃ³n de mantenimiento. Limpia tokens de reset de contraseÃ±a expirados. Debe ejecutarse periÃ³dicamente via cron job';

-- ====================================================================
-- ğŸ”“ FUNCIÃ“N 3: DESBLOQUEAR_USUARIOS_AUTOMATICO
-- ====================================================================
-- FunciÃ³n para desbloquear usuarios automÃ¡ticamente
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION desbloquear_usuarios_automatico()
RETURNS INTEGER AS $$
DECLARE
    usuarios_desbloqueados INTEGER;
BEGIN
    -- Configurar bypass RLS para funciÃ³n de mantenimiento
    PERFORM set_config('app.bypass_rls', 'true', true);

    UPDATE usuarios
    SET bloqueado_hasta = NULL,
        intentos_fallidos = 0,
        actualizado_en = NOW()
    WHERE bloqueado_hasta < NOW()
    AND bloqueado_hasta IS NOT NULL;

    GET DIAGNOSTICS usuarios_desbloqueados = ROW_COUNT;

    -- Log del mantenimiento (se agregarÃ¡ eventos_sistema en fase posterior)
    -- TODO: Implementar log de mantenimiento cuando eventos_sistema estÃ© disponible

    -- Limpiar bypass RLS
    PERFORM set_config('app.bypass_rls', 'false', true);

    RETURN usuarios_desbloqueados;
END;
$$ LANGUAGE plpgsql;

-- ====================================================================
-- ğŸ“§ FUNCIÃ“N 4: VALIDAR_EMAIL_USUARIO
-- ====================================================================
-- FunciÃ³n para validar email Ãºnico por organizaciÃ³n
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION validar_email_usuario()
RETURNS TRIGGER AS $$
BEGIN
    -- Para super_admin, email debe ser Ãºnico globalmente
    IF NEW.rol = 'super_admin' THEN
        IF EXISTS (
            SELECT 1 FROM usuarios
            WHERE email = NEW.email
            AND id != COALESCE(NEW.id, 0)
            AND activo = TRUE
        ) THEN
            RAISE EXCEPTION 'Email ya existe en el sistema';
        END IF;
    ELSE
        -- Para otros roles, email Ãºnico por organizaciÃ³n
        IF EXISTS (
            SELECT 1 FROM usuarios
            WHERE email = NEW.email
            AND organizacion_id = NEW.organizacion_id
            AND id != COALESCE(NEW.id, 0)
            AND activo = TRUE
        ) THEN
            RAISE EXCEPTION 'Email ya existe en esta organizaciÃ³n';
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ====================================================================
-- â° FUNCIÃ“N 5: ACTUALIZAR_TIMESTAMP
-- ====================================================================
-- FunciÃ³n para actualizar timestamp automÃ¡ticamente
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION actualizar_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.actualizado_en = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ====================================================================
-- ğŸ­ FUNCIÃ“N 6: VALIDAR_PROFESIONAL_INDUSTRIA
-- ====================================================================
-- FunciÃ³n para validar compatibilidad tipo profesional con industria
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION validar_profesional_industria()
RETURNS TRIGGER AS $$
DECLARE
    industria_org industria_tipo;
BEGIN
    -- Obtener la industria de la organizaciÃ³n
    SELECT tipo_industria INTO industria_org
    FROM organizaciones
    WHERE id = NEW.organizacion_id;

    -- Validar compatibilidad segÃºn industria
    CASE industria_org
        WHEN 'barberia' THEN
            IF NEW.tipo_profesional NOT IN ('barbero', 'estilista_masculino', 'estilista') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria barberia', NEW.tipo_profesional;
            END IF;

        WHEN 'salon_belleza' THEN
            IF NEW.tipo_profesional NOT IN ('estilista', 'colorista', 'manicurista', 'peinados_eventos') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria salon_belleza', NEW.tipo_profesional;
            END IF;

        WHEN 'estetica' THEN
            IF NEW.tipo_profesional NOT IN ('esteticista', 'cosmetologo', 'depilacion_laser') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria estetica', NEW.tipo_profesional;
            END IF;

        WHEN 'spa' THEN
            IF NEW.tipo_profesional NOT IN ('masajista', 'terapeuta_spa', 'aromaterapeuta', 'reflexologo') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria spa', NEW.tipo_profesional;
            END IF;

        WHEN 'podologia' THEN
            IF NEW.tipo_profesional NOT IN ('podologo', 'asistente_podologia') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria podologia', NEW.tipo_profesional;
            END IF;

        WHEN 'consultorio_medico' THEN
            IF NEW.tipo_profesional NOT IN ('doctor_general', 'enfermero', 'recepcionista_medica') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria consultorio_medico', NEW.tipo_profesional;
            END IF;

        WHEN 'academia' THEN
            IF NEW.tipo_profesional NOT IN ('instructor', 'profesor', 'tutor') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria academia', NEW.tipo_profesional;
            END IF;

        WHEN 'taller_tecnico' THEN
            IF NEW.tipo_profesional NOT IN ('tecnico_auto', 'tecnico_electronico', 'mecanico', 'soldador') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria taller_tecnico', NEW.tipo_profesional;
            END IF;

        WHEN 'centro_fitness' THEN
            IF NEW.tipo_profesional NOT IN ('entrenador_personal', 'instructor_yoga', 'instructor_pilates', 'nutricionista') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria centro_fitness', NEW.tipo_profesional;
            END IF;

        WHEN 'veterinaria' THEN
            IF NEW.tipo_profesional NOT IN ('veterinario', 'asistente_veterinario', 'groomer') THEN
                RAISE EXCEPTION 'Tipo profesional % no compatible con industria veterinaria', NEW.tipo_profesional;
            END IF;

        WHEN 'otro' THEN
            -- Para industria "otro", permitir cualquier tipo profesional incluido "otro"
            NULL;

        ELSE
            RAISE EXCEPTION 'Industria % no reconocida', industria_org;
    END CASE;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Comentario de la funciÃ³n
COMMENT ON FUNCTION validar_profesional_industria() IS
'Valida automÃ¡ticamente que el tipo_profesional sea compatible con la industria de la organizaciÃ³n. Previene asignaciones incorrectas';

-- ====================================================================
-- ğŸ›ï¸ FUNCIÃ“N 7: ACTUALIZAR_TIMESTAMP_SERVICIOS
-- ====================================================================
-- FunciÃ³n para actualizar timestamp en servicios
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION actualizar_timestamp_servicios()
RETURNS TRIGGER AS $$
BEGIN
    NEW.actualizado_en = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Comentarios en funciones
COMMENT ON FUNCTION actualizar_timestamp_servicios() IS
'Actualiza automÃ¡ticamente el campo actualizado_en cuando se modifica un servicio o relaciÃ³n servicio-profesional';

-- ====================================================================
-- ğŸ“… FUNCIÃ“N 8: ACTUALIZAR_TIMESTAMP_CITAS
-- ====================================================================
-- FunciÃ³n para actualizar timestamp y versiÃ³n en citas
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION actualizar_timestamp_citas()
RETURNS TRIGGER AS $$
BEGIN
    NEW.actualizado_en = NOW();
    NEW.version = OLD.version + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ====================================================================
-- ğŸ›¡ï¸ FUNCIÃ“N 9: VALIDAR_COHERENCIA_CITA
-- ====================================================================
-- FunciÃ³n para validar coherencia organizacional en citas
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION validar_coherencia_cita()
RETURNS TRIGGER AS $$
DECLARE
    cliente_org INTEGER;
    profesional_org INTEGER;
    servicio_org INTEGER;
BEGIN
    -- Obtener organizaciones de las entidades relacionadas
    SELECT organizacion_id INTO cliente_org FROM clientes WHERE id = NEW.cliente_id;
    SELECT organizacion_id INTO profesional_org FROM profesionales WHERE id = NEW.profesional_id;
    SELECT organizacion_id INTO servicio_org FROM servicios WHERE id = NEW.servicio_id;

    -- Validar coherencia
    IF NEW.organizacion_id != cliente_org OR
       NEW.organizacion_id != profesional_org OR
       NEW.organizacion_id != servicio_org THEN
        RAISE EXCEPTION 'Incoherencia organizacional: cliente (%), profesional (%), servicio (%) deben pertenecer a organizaciÃ³n (%)',
            cliente_org, profesional_org, servicio_org, NEW.organizacion_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Comentarios en funciones
COMMENT ON FUNCTION actualizar_timestamp_citas() IS 'Actualiza automÃ¡ticamente timestamp y versiÃ³n al modificar una cita';
COMMENT ON FUNCTION validar_coherencia_cita() IS 'Valida que cliente, profesional y servicio pertenezcan a la misma organizaciÃ³n';

-- ====================================================================
-- ğŸ—“ï¸ FUNCIÃ“N 10: ACTUALIZAR_TIMESTAMP_HORARIOS
-- ====================================================================
-- FunciÃ³n para actualizar timestamp y versiÃ³n en horarios
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION actualizar_timestamp_horarios()
RETURNS TRIGGER AS $$
BEGIN
    NEW.actualizado_en = NOW();
    NEW.version = OLD.version + 1;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ====================================================================
-- ğŸ›¡ï¸ FUNCIÃ“N 11: VALIDAR_COHERENCIA_HORARIO
-- ====================================================================
-- FunciÃ³n para validar coherencia organizacional en horarios
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION validar_coherencia_horario()
RETURNS TRIGGER AS $$
DECLARE
    profesional_org INTEGER;
    servicio_org INTEGER;
    cita_org INTEGER;
BEGIN
    -- Validar organizaciÃ³n del profesional
    SELECT organizacion_id INTO profesional_org FROM profesionales WHERE id = NEW.profesional_id;

    IF NEW.organizacion_id != profesional_org THEN
        RAISE EXCEPTION 'Incoherencia organizacional: profesional (%) debe pertenecer a organizaciÃ³n (%)',
            profesional_org, NEW.organizacion_id;
    END IF;

    -- Validar organizaciÃ³n del servicio si estÃ¡ especificado
    IF NEW.servicio_id IS NOT NULL THEN
        SELECT organizacion_id INTO servicio_org FROM servicios WHERE id = NEW.servicio_id;
        IF NEW.organizacion_id != servicio_org THEN
            RAISE EXCEPTION 'Incoherencia organizacional: servicio (%) debe pertenecer a organizaciÃ³n (%)',
                servicio_org, NEW.organizacion_id;
        END IF;
    END IF;

    -- Validar organizaciÃ³n de la cita si estÃ¡ especificada
    IF NEW.cita_id IS NOT NULL THEN
        SELECT organizacion_id INTO cita_org FROM citas WHERE id = NEW.cita_id;
        IF NEW.organizacion_id != cita_org THEN
            RAISE EXCEPTION 'Incoherencia organizacional: cita (%) debe pertenecer a organizaciÃ³n (%)',
                cita_org, NEW.organizacion_id;
        END IF;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ====================================================================
-- ğŸ§¹ FUNCIÃ“N 12: LIMPIAR_RESERVAS_EXPIRADAS
-- ====================================================================
-- FunciÃ³n de limpieza automÃ¡tica de reservas expiradas
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION limpiar_reservas_expiradas()
RETURNS INTEGER AS $$
DECLARE
    reservas_limpiadas INTEGER;
BEGIN
    UPDATE horarios_disponibilidad
    SET estado = 'disponible',
        reservado_hasta = NULL,
        reservado_por = NULL,
        session_id = NULL,
        token_reserva = NULL,
        capacidad_ocupada = 0
    WHERE estado = 'reservado_temporal'
    AND reservado_hasta < NOW();

    GET DIAGNOSTICS reservas_limpiadas = ROW_COUNT;
    RETURN reservas_limpiadas;
END;
$$ LANGUAGE plpgsql;

-- ====================================================================
-- ğŸ”„ FUNCIÃ“N 13: GENERAR_HORARIOS_RECURRENTES
-- ====================================================================
-- FunciÃ³n para generar horarios recurrentes
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION generar_horarios_recurrentes(
    p_profesional_id INTEGER,
    p_fecha_inicio DATE,
    p_fecha_fin DATE
) RETURNS INTEGER AS $$
DECLARE
    horario_base RECORD;
    fecha_actual DATE;
    horarios_creados INTEGER := 0;
BEGIN
    -- Obtener horarios base recurrentes
    FOR horario_base IN
        SELECT * FROM horarios_disponibilidad
        WHERE profesional_id = p_profesional_id
        AND es_recurrente = TRUE
        AND tipo_horario = 'regular'
        AND (fecha_fin_recurrencia IS NULL OR fecha_fin_recurrencia >= p_fecha_inicio)
    LOOP
        fecha_actual := p_fecha_inicio;

        WHILE fecha_actual <= p_fecha_fin LOOP
            -- Verificar si corresponde al dÃ­a de la semana
            IF EXTRACT(DOW FROM fecha_actual) = horario_base.dia_semana THEN
                -- Insertar horario si no existe
                INSERT INTO horarios_disponibilidad (
                    organizacion_id, profesional_id, servicio_id,
                    tipo_horario, fecha, hora_inicio, hora_fin, zona_horaria,
                    estado, duracion_slot, capacidad_maxima,
                    precio_base, es_horario_premium,
                    creado_automaticamente, algoritmo_creacion,
                    creado_por
                ) VALUES (
                    horario_base.organizacion_id, horario_base.profesional_id, horario_base.servicio_id,
                    'franja_especifica', fecha_actual, horario_base.hora_inicio, horario_base.hora_fin, horario_base.zona_horaria,
                    'disponible', horario_base.duracion_slot, horario_base.capacidad_maxima,
                    horario_base.precio_base, horario_base.es_horario_premium,
                    TRUE, 'sistema_recurrencia',
                    horario_base.creado_por
                )
                ON CONFLICT (profesional_id, fecha, hora_inicio) DO NOTHING;

                horarios_creados := horarios_creados + 1;
            END IF;

            fecha_actual := fecha_actual + INTERVAL '1 day';
        END LOOP;
    END LOOP;

    RETURN horarios_creados;
END;
$$ LANGUAGE plpgsql;

-- Comentarios en funciones de horarios
COMMENT ON FUNCTION actualizar_timestamp_horarios() IS 'Actualiza automÃ¡ticamente timestamp y versiÃ³n al modificar un horario';
COMMENT ON FUNCTION validar_coherencia_horario() IS 'Valida que profesional, servicio y cita pertenezcan a la misma organizaciÃ³n';
COMMENT ON FUNCTION limpiar_reservas_expiradas() IS 'Limpia automÃ¡ticamente reservas temporales expiradas y libera capacidad';
COMMENT ON FUNCTION generar_horarios_recurrentes(INTEGER, DATE, DATE) IS 'Genera automÃ¡ticamente horarios especÃ­ficos basados en patrones recurrentes';

-- ====================================================================
-- ğŸ“ FUNCIÃ“N 14: NORMALIZAR_TELEFONO
-- ====================================================================
-- FunciÃ³n auxiliar para normalizaciÃ³n consistente de nÃºmeros telefÃ³nicos.
-- CRÃTICA para las funciones de bÃºsqueda fuzzy del modelo cliente.
--
-- ğŸ¯ PROPÃ“SITO:
-- â€¢ Remover caracteres no numÃ©ricos (espacios, guiones, parÃ©ntesis)
-- â€¢ Remover cÃ³digos de paÃ­s comunes (52 MÃ©xico, 1 USA)
-- â€¢ Garantizar consistencia en bÃºsquedas por telÃ©fono
--
-- ğŸ“‹ PARÃMETROS:
-- â€¢ telefono_input: TelÃ©fono en cualquier formato
--
-- ğŸ“Š RETORNA: TelÃ©fono normalizado (solo nÃºmeros)
--
-- ğŸ”§ EJEMPLOS DE USO:
-- â€¢ normalizar_telefono('+52 55 1234-5678') â†’ '525512345678'
-- â€¢ normalizar_telefono('+1 (555) 123-4567') â†’ '15551234567'
-- â€¢ normalizar_telefono('55-1234-5678') â†’ '5512345678'
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CREATE OR REPLACE FUNCTION normalizar_telefono(telefono_input TEXT)
RETURNS TEXT AS $$
BEGIN
    -- Validar entrada nula
    IF telefono_input IS NULL THEN
        RETURN NULL;
    END IF;

    -- NormalizaciÃ³n en dos pasos:
    -- 1. Remover cÃ³digos de paÃ­s comunes (52 MÃ©xico, 1 USA)
    -- 2. Remover todos los caracteres no numÃ©ricos
    RETURN regexp_replace(
        regexp_replace(telefono_input, '^(52|1)', ''),
        '[^0-9]', '', 'g'
    );
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- ğŸ“ COMENTARIO DE FUNCIÃ“N EN BD
COMMENT ON FUNCTION normalizar_telefono(TEXT) IS
'Normaliza nÃºmeros telefÃ³nicos removiendo caracteres especiales y cÃ³digos de paÃ­s. Optimizada para bÃºsquedas fuzzy en modelos de cliente';
